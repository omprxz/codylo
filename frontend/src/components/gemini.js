import {
  useState
} from 'react'
import {
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold
} from "@google/generative-ai";

const Gemini = async (parts, geminiErr=0, setErrorCode, setResultsVisib, stream = true, handleChunk = '', scroll, model = "gemini-1.5-flash", geminiApiIndex = 1) => {
  const gemini_apis = process.env.REACT_APP_GEMINI_APIS.split(',')
  const gemini_api = gemini_apis[geminiApiIndex].trim()
  const genAI = new GoogleGenerativeAI(gemini_api);
  const generationConfig = {
      temperature: 0.5,
      topP: 0.6,
      topK: 50,
      maxOutputTokens: 10000,
      responseMimeType: "text/plain",
    };
  const scrollDown = (px) => {
    window.scrollBy({
      top: px,
      behavior: 'smooth'
    });
  };
    try {
      let result = await genAI.getGenerativeModel({
    model: model,
    generationConfig,
    safetySettings: [
        {
            category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
            threshold: 'BLOCK_NONE'
        },
        {
            category: 'HARM_CATEGORY_HATE_SPEECH',
            threshold: 'BLOCK_NONE'
        },
        {
            category: 'HARM_CATEGORY_HARASSMENT',
            threshold: 'BLOCK_NONE'
        },
        {
            category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
            threshold: 'BLOCK_NONE'
        }
    ]
})
      if(stream){
        result = await result.generateContentStream({
        contents: [{
          role: "user", parts
        }]
      });
      
      setResultsVisib(true)
      let scrollStop = 0;
      for await (const chunk of result.stream){
      const chunkText = chunk.text()
      handleChunk(chunkText)
      
      if(scroll && (scrollStop % 5 == 0) && scrollStop <= 20){
        scrollDown(100)
      }
      scrollStop++
    }
      }else{
        result = await result.generateContent({
        contents: [{
          role: "user", parts
        }]
      });
      }

      let generatedCode = await result.response;
      generatedCode = generatedCode.text();
      return generatedCode;
    } catch (error) {
      console.log(error.message)
      if (error.status === 429) {
        try {
          let result = await genAI.getGenerativeModel({
    model: model,
    generationConfig,
    safetySettings: [
        {
            category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
            threshold: 'BLOCK_NONE'
        },
        {
            category: 'HARM_CATEGORY_HATE_SPEECH',
            threshold: 'BLOCK_NONE'
        },
        {
            category: 'HARM_CATEGORY_HARASSMENT',
            threshold: 'BLOCK_NONE'
        },
        {
            category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
            threshold: 'BLOCK_NONE'
        }
    ]
})
      if(stream){
        result = await result.generateContentStream({
        contents: [{
          role: "user", parts
        }]
      });
      
      setResultsVisib(true)
      let scrollStop = 0;
      for await (const chunk of result.stream){
      const chunkText = chunk.text()
      handleChunk(chunkText)
      
      if(scroll && (scrollStop % 5 == 0) && scrollStop <= 20){
        scrollDown(100)
      }
      scrollStop++
    }
      }else{
        result = await result.generateContent({
        contents: [{
          role: "user", parts
        }]
      });
      }

      let generatedCode = await result.response;
      generatedCode = generatedCode.text();
          console.log("Generated by 1.0 pro")
      return generatedCode;
        } catch (error) {
          console.log(error.message)
          geminiErr = 1
          setErrorCode(true)
          return 'Fail to generate'
        }
      }
      geminiErr = 1
      setErrorCode(true)
      return 'Fail to generate'
    }
  
  
}

export default Gemini;